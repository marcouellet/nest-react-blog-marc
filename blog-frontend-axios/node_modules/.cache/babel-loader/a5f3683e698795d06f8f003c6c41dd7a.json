{"ast":null,"code":"const getArrayBuffer = file => {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n\n    reader.onload = () => resolve(reader.result);\n\n    reader.onerror = error => reject(error);\n\n    reader.readAsArrayBuffer(file);\n  });\n};\n\nexport function getImageFromFile(file, callback, errorHandler) {\n  getArrayBuffer(file).then(data => {\n    const imageData = {\n      base64: Buffer.from(data).toString('base64'),\n      contentType: file.type\n    };\n    callback(imageData);\n  }).catch(error => errorHandler(error));\n}\nexport function resizeImage(imageData, maxWidth, maxHeight) {\n  return new Promise((resolve, reject) => {\n    let image = new Image();\n    image.src = 'data:' + imageData.contentType.trim() + ';base64,' + imageData.base64;\n\n    image.onload = () => {\n      let width = image.width;\n      let height = image.height;\n\n      if (width <= maxWidth && height <= maxHeight) {\n        resolve(imageData);\n      }\n\n      let newWidth;\n      let newHeight;\n\n      if (width > height) {\n        newHeight = height * (maxWidth / width);\n        newWidth = maxWidth;\n      } else {\n        newWidth = width * (maxHeight / height);\n        newHeight = maxHeight;\n      }\n\n      let canvas = document.createElement('canvas');\n      canvas.width = newWidth;\n      canvas.height = newHeight;\n      let context = canvas.getContext('2d');\n      context.drawImage(image, 0, 0, newWidth, newHeight);\n      canvas.toBlob(blob => {\n        blob === null || blob === void 0 ? void 0 : blob.arrayBuffer().then(array => {\n          const base64 = Buffer.from(array).toString('base64');\n          const newImageData = {\n            base64: base64,\n            contentType: imageData.contentType.trim()\n          };\n          resolve(newImageData);\n        });\n      });\n    };\n\n    image.onerror = reject;\n  });\n}","map":{"version":3,"sources":["F:/Documents/Documents/_Nest/nest-react-blog-marc/blog-frontend-axios/src/utils/image.utils.ts"],"names":["getArrayBuffer","file","Promise","resolve","reject","reader","FileReader","onload","result","onerror","error","readAsArrayBuffer","getImageFromFile","callback","errorHandler","then","data","imageData","base64","Buffer","from","toString","contentType","type","catch","resizeImage","maxWidth","maxHeight","image","Image","src","trim","width","height","newWidth","newHeight","canvas","document","createElement","context","getContext","drawImage","toBlob","blob","arrayBuffer","array","newImageData"],"mappings":"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","sourcesContent":["import { ImageData } from '../types';\r\n\r\nconst getArrayBuffer = (file: File) => {\r\n    return new Promise<ArrayBuffer>((resolve,reject) => {\r\n       const reader = new FileReader();\r\n       reader.onload = () => resolve(reader.result as ArrayBuffer);\r\n       reader.onerror = error => reject(error);\r\n       reader.readAsArrayBuffer(file);\r\n    });\r\n}\r\n\r\nexport type GetImageCallback = (imageData: ImageData) => {}\r\nexport type GetImageErrorCallback = (error: any) => {}\r\n\r\nexport function getImageFromFile(file: File, callback: GetImageCallback, errorHandler: GetImageErrorCallback) {\r\n\r\n    getArrayBuffer(file).then(data => {\r\n        const imageData: ImageData = { base64: Buffer.from(data).toString('base64'), contentType: file.type };\r\n        callback(imageData);\r\n    })\r\n    .catch((error) => errorHandler(error));\r\n}\r\n\r\nexport function resizeImage(imageData:ImageData, maxWidth:number, maxHeight:number): Promise<ImageData> {\r\n\r\n    return new Promise<ImageData>((resolve, reject) => {\r\n\r\n        let image = new Image();\r\n        image.src = 'data:' + imageData.contentType.trim() + ';base64,' + imageData.base64;\r\n        image.onload = () => {\r\n            let width = image.width;\r\n            let height = image.height;\r\n            \r\n            if (width <= maxWidth && height <= maxHeight) {\r\n                resolve(imageData);\r\n            }\r\n\r\n            let newWidth;\r\n            let newHeight;\r\n\r\n            if (width > height) {\r\n                newHeight = height * (maxWidth / width);\r\n                newWidth = maxWidth;\r\n            } else {\r\n                newWidth = width * (maxHeight / height);\r\n                newHeight = maxHeight;\r\n            }\r\n\r\n            let canvas = document.createElement('canvas');\r\n            canvas.width = newWidth;\r\n            canvas.height = newHeight;\r\n\r\n            let context = canvas.getContext('2d');\r\n\r\n            context!.drawImage(image, 0, 0, newWidth, newHeight);\r\n\r\n            canvas.toBlob(blob => {\r\n                blob?.arrayBuffer()\r\n                    .then((array) => {\r\n                        const base64 = Buffer.from(array).toString('base64');\r\n                        const newImageData : ImageData = {base64: base64, contentType: imageData.contentType.trim() };\r\n                        resolve(newImageData);\r\n                    });\r\n            });\r\n        };\r\n        image.onerror = reject;\r\n    });\r\n}\r\n"]},"metadata":{},"sourceType":"module"}